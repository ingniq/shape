# Учебная задача "Утилиты для геометрических фигур"
## Описание
Необходимо написать на C# библиотеку для поставки внешним клиентам, которая умеет вычислять площадь круга по радиусу и треугольника по трем сторонам.

Дополнительные моменты:  
&nbsp;&nbsp;&nbsp;&nbsp;&#9745; написать юнит-тесты;  
&nbsp;&nbsp;&nbsp;&nbsp;&#9745; обеспечить легкость добавления других фигур;  
&nbsp;&nbsp;&nbsp;&nbsp;&#9745; площади фигуры должны вычисляться без знания типа фигуры в compile-time;  
&nbsp;&nbsp;&nbsp;&nbsp;&#9745; добавить проверку на то, является ли треугольник прямоугольным.

Реализовывать будем в проекте ShapeUtils.

## Выполнение
### 1. Фигуры
Мы будем создавать различные фигуры у которых должен быть один общий метод -- `CalculateArea()`.

Кроме этого дополнительно можно добавить еще один общий для всех метод для валидации создаваемых объектов -- `Validate()`.

Таким образом абстрагируем эти два общих момента в отдельный абстрактный класс `Shape`, от которого будут наследоваться конкретные классы-фигуры.

Метод `CalculateArea()` будет абстрактным, обязательным для реализации в классах-наследниках.

### 2. Создание фигур
Далее для создания геометрических фигур удобно использовать фабричный метод.
Для этого создадим класс `ShapeFactory` со статическим методом `CreateShape`.

В метод `CreateShape` нужно передавать данные, которые определяют тип создаваемой фигуры, а также необходимые для этого данные.

По мимо этого важный момент в том, что метод `CreateShape` будет возвращать тип `Shape`. Таким образом класс `ShapeFactory` будет иметь зависимость только от абстрактного класса `Shape` (а не от конкретной фигуры), у которого есть метод `CalculateArea()`. Здесь обеспечивается условие вычисления площади фигур без знания типа фигуры в compile-time.

### 3. Дополнительные типы данных
Для фабричного метода `CreateShape` нужно передать данные о создаваемой фигуре.
Пока планируется создавать только два типа:
- круг;
- треугольник.

Создадим тип `enum ShapeType` с данными типами фигур. Далее будет удобно добавлять новые типы в это перечисление.
```csharp
public enum ShapeType
{
    Circle,
    Triangle
}
```

Кроме этого можно передавать измерения, необходимые для создания фигуры. Для каждой фигуры они свои. Например для круга это будет радиус, а для треугольника -- три стороны (могут быть и другие данные, по которым можно построить фигуру).

Таким образом у нас есть одна общая часть для все типов данных, которую нужно передать в фабричный метод -- тип фигуры.

Определим интерфейс `IShapeParameters` нового типа данных:
```csharp
public interface IShapeParameters
{
    public ShapeType Type { get; }
}
```

Далее определим типы параметров для текущих типов фигур:
```csharp
public struct CircleParameters : IShapeParameters
{
    public readonly ShapeType Type => ShapeType.Circle;
    public double Radius;
}

public struct TriangleParameters : IShapeParameters
{
    public readonly ShapeType Type => ShapeType.Triangle;
    public double SideA;
    public double SideB;
    public double SideC;
}
```

По мимо этих данных также в будущем возможно понадобятся и другие данные. Например в случае с треугольником можно добавить три угла в тип `TriangleParameters`, описывающих более полно его. 

Треугольник можно построить не только по трем сторонам, но и по двум сторонам и углу между ними, а также по одной стороне и прилежащим к ней углам.

Для случая нескольких вариантов создания фигуры по разному набору данных уместно обеспечить возможность параметрического полиморфизма.

Для этого, по скольку тип данных для разных измерений одинаков (double), можно создать свои типы данных -- `Angle`, `Side`, `Radius`.

Таким образом мы можем использовать несколько конструкторов с разными наборами параметров для создания фигур.

На примере треугольника:
```csharp
public Triangle(Side sideA, Side sideB, Side sideC) {}
public Triangle(Side sideA, Side sideB, Angle angleAB) {}
public Triangle(Side side, Angle angle1, Angle angle2) {}
```

Что касается фабричного метода, то итоге получаем следующее:
```csharp
public static Shape CreateShape(IShapeParameters shapeParameters)
{
    return shapeParameters.Type switch
    {
        ShapeType.Circle => CreateCircle((CircleParameters)shapeParameters),
        ShapeType.Triangle => CreateTriangle((TriangleParameters)shapeParameters),
        _ => throw new NotImplementedException(),
    };
}
```
### 4. Реализация конкретных фигур
Осталось реализовать классы конкретных фигур -- круг и треугольник.
Оба необходимо наследовать от абстрактного класса `Shape`, что обязывает реализовать метод `CalculateArea()` в каждом.

По мимо этого в классе треугольника необходимо реализовать метод проверки прямоугольности данного треугольника.
### 5. Валидация объектов
При создании объектов фигур необходимо учесть корректность переданных данных.
Например переданные велечины должны быть положительными, кроме того можно проверить возможность численного переполнения при различных операциях.

Для треугольника имеет смысл выполнить также проверку на существование.
### 6. Юнит-тесты
Тесты реализуем в проекте ShapeUtils.Tests, добавив его в Solution и указав в новом проекте ссылку на основной проект.

В тестах необходимо рассмотреть набор крайних и основных случаев, протестировать валидацию, случаи ошибок и исключений.
### 7. Поставка внешним клиентам
В проекте ShapeUtils в файле `.csproj` необходимо заполнить раздел `<PropertyGroup Label="Package">`.

`PackageId` предположим укажем `ShapeUtils.04.10.23.001`.

Далее для тестирования можно создать на локальной машине репозиторий пакетов:
```
dotnet nuget add source ~/.net/packages
```
Потом создадим пакет (файл `ShapeUtils.04.10.23.001.nupkg`) командой:
```
dotnet pack --configuration Release -o ~/.net/packages
```
В другом проекте ("внешнем клиенте") можно распаковать этот пакет командой:
```
dotnet add package ShapeUtils.04.10.23.001
```

Вместо локального размещения можно пакет отправить в репозиторий NuGet.
## Итог

В итоге получаем такую схему использования продукта:
```csharp
CircleParameters circleParameters = new{
    Radius = new Radius(10)
};

TriangleParameters triangleParameters = new{
    SideA = new Side(3),
    SideB = new Side(4),
    SideC = new Side(5)
};

Shape circle = ShapeFactory.CreateShape(circleParameters);
Shape triangle = ShapeFactory.CreateShape(triangleParameters);

double circleArea = circle.CalculateArea();
double triangleArea = triangle.CalculateArea();
bool isRightTriangle = triangle.IsRightTriangle();
```

Для добавления новых фигур потребуется:
- добавить новый тип фигуры в `enum ShapeType`;
- описать параметры фигуры в типе с интерфейсом `IShapeParameters`;
- описать непосредственно сам новый тип фигуры, наследуемый от абстрактного класса `Shape`, а также валидации при необходимости;
- добавить обработку в `ShapeFactory`.
